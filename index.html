<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VDC Contador de Patas — B2/B3</title>
  <style>
    :root{
      --bg1:#08101f; --bg2:#060b16;
      --card: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.10);
      --text:#eaf0ff; --muted: rgba(234,240,255,.65);
      --green:#32d07f; --amber:#caa24a; --red:#e05555; --blue:#4aa3ff;
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh;
      background: radial-gradient(1200px 700px at 20% 10%, #0b2a5a 0%, var(--bg1) 45%, var(--bg2) 100%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      padding:18px;
    }
    .topbar{display:flex;align-items:center;gap:12px;margin-bottom:14px}
    .pill{
      display:inline-flex;align-items:center;gap:10px;
      padding:8px 12px;border:1px solid var(--stroke);
      background:rgba(0,0,0,.25);border-radius:999px;
      font-weight:700;letter-spacing:.3px
    }
    .dot{width:10px;height:10px;border-radius:50%;background:var(--green);box-shadow:0 0 14px rgba(50,208,127,.7)}
    h1{margin:0;font-size:22px}
    .sub{color:var(--muted);margin-top:4px;font-size:13px}

    .grid{display:grid;grid-template-columns: 1.25fr .95fr;gap:14px;align-items:start}
    @media(max-width:980px){.grid{grid-template-columns:1fr}}

    .card{
      border:1px solid var(--stroke);
      background:var(--card);
      border-radius:18px;
      padding:14px;
      box-shadow: 0 18px 50px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
    }
    .card h2{margin:0 0 10px 0;font-size:16px}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .spacer{flex:1}
    .btn{
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:12px 14px;border-radius:14px;
      font-weight:800;cursor:pointer;
      min-width:160px;text-align:center;
      user-select:none;
    }
    .btn:active{transform:scale(.99)}
    .btn.green{background:rgba(50,208,127,.22);border-color:rgba(50,208,127,.45)}
    .btn.amber{background:rgba(202,162,74,.22);border-color:rgba(202,162,74,.45)}
    .btn.red{background:rgba(224,85,85,.22);border-color:rgba(224,85,85,.45)}
    .btn.blue{background:rgba(74,163,255,.20);border-color:rgba(74,163,255,.42)}
    .btn.ghost{opacity:.65}
    .btn.full{width:100%}
    .btn.small{padding:10px 12px;min-width:unset}

    .big{
      font-size:84px;font-weight:900;line-height:1;letter-spacing:-2px;
      margin:10px 0 0 0;
    }
    .label{color:var(--muted);font-weight:700}
    .statusline{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .tag{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.18);
      font-weight:800;font-size:12px;color:var(--muted)
    }
    .tag strong{color:var(--text)}
    .tag.ok{border-color:rgba(50,208,127,.4)}
    .tag.warn{border-color:rgba(202,162,74,.4)}
    .tag.bad{border-color:rgba(224,85,85,.4)}
    .tag.blue{border-color:rgba(74,163,255,.4)}

    .field{
      width:100%;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.20);
      color:var(--text);
      font-weight:700;
      outline:none;
    }
    .mini{font-size:12px;color:var(--muted);margin-top:8px}

    .camWrap{position:relative;border-radius:18px;overflow:hidden;border:1px solid var(--stroke)}
    video{width:100%;display:block;background:#000;aspect-ratio: 16/9;object-fit:cover}
    canvas{position:absolute;inset:0;width:100%;height:100%;pointer-events:none}

    .flash{
      position:fixed;inset:0;pointer-events:none;
      background:rgba(50,208,127,.18);
      opacity:0;transition:opacity .12s ease;
    }
    .flash.on{opacity:1}
    .log{max-height:260px;overflow:auto;border-radius:14px;border:1px solid var(--stroke);padding:10px;background:rgba(0,0,0,.18)}
    .logItem{display:flex;justify-content:space-between;gap:10px;padding:8px 8px;border-bottom:1px solid rgba(255,255,255,.06)}
    .logItem:last-child{border-bottom:none}
    .logItem b{font-weight:900}
    .right{text-align:right;color:var(--muted);font-weight:800}
    .hr{height:1px;background:rgba(255,255,255,.08);margin:12px 0}
    .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media(max-width:980px){.two{grid-template-columns:1fr}}
    .k{font-weight:900}
    .sliderRow{display:grid;grid-template-columns:1fr 110px;gap:10px;align-items:center}
    input[type="range"]{width:100%}
    .num{padding:10px 10px;border-radius:12px;border:1px solid var(--stroke);background:rgba(0,0,0,.18);text-align:center;font-weight:900}
  </style>
</head>

<body>
  <div class="flash" id="flash"></div>

  <div class="topbar">
    <div class="pill"><span class="dot"></span>ONLINE</div>
    <div>
      <h1>VDC Contador de Patas</h1>
      <div class="sub">Paso B2 (movimiento) + Paso B3 (detección con Roboflow). Guardado local.</div>
    </div>
  </div>

  <div class="grid">
    <!-- IZQUIERDA -->
    <div class="card">
      <h2>Conteo</h2>

      <div class="row">
        <div>
          <div class="big" id="count">0</div>
          <div class="label">patas</div>
        </div>
        <div class="spacer"></div>

        <div style="min-width:280px">
          <input class="field" id="sessionName" placeholder="Nombre de sesión (opcional) Ej. Camión 7:00 AM - Martes">
          <div class="statusline">
            <span class="tag ok"><strong id="savedState">Guardado:</strong> <span id="savedText">listo</span></span>
            <span class="tag blue"><strong>Último:</strong> <span id="lastSaved">—</span></span>
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <div class="btn green" id="btnStart">INICIAR</div>
        <div class="btn ghost" id="btnPause">PAUSAR</div>
        <div class="btn amber" id="btnPlus">+1 PATA</div>
        <div class="btn ghost" id="btnUndo">DESHACER</div>
        <div class="btn red" id="btnReset">REINICIAR A CERO</div>
        <div class="btn blue" id="btnCSV">EXPORTAR (CSV)</div>
      </div>

      <div class="mini">
        Tip: iPhone fijo en tripié apuntando al tanque IBP. Cuenta cuando la pata entra al ROI y cruza la línea.
      </div>

      <div class="hr"></div>

      <div class="two">
        <div class="card" style="padding:12px">
          <h2 style="margin:0 0 10px 0">Modo Cámara</h2>
          <div class="row">
            <button class="btn green small" id="btnCamOn">ACTIVAR CÁMARA</button>
            <button class="btn small" id="btnCamOff">APAGAR</button>
            <button class="btn small" id="btnFlip">CAMBIAR CÁMARA</button>
          </div>

          <div class="hr"></div>

          <div class="row">
            <span class="tag warn"><strong>Estado:</strong> <span id="runState">PAUSADO</span></span>
            <span class="tag blue"><strong>Modo:</strong> <span id="modeText">B2</span></span>
            <span class="tag"><strong>Debug:</strong> <span id="dbgText">OFF</span></span>
          </div>

          <div class="hr"></div>

          <div class="row">
            <button class="btn small blue" id="btnMode">CAMBIAR B2/B3</button>
            <button class="btn small" id="btnDebug">DEBUG</button>
            <button class="btn small" id="btnCalib">CALIBRAR (10s)</button>
          </div>

          <div class="mini">
            B2 = movimiento (rápido). B3 = Roboflow “pata” (más estable).  
            Si “no contó”: baja ROI, sube cooldown o ajusta confianza (en el código).
          </div>
        </div>

        <div class="card" style="padding:12px">
          <h2 style="margin:0 0 10px 0">Ajustes (en vivo)</h2>

          <div class="sliderRow">
            <div>
              <div class="label">ROI (tamaño del cuadro)</div>
              <input id="roi" type="range" min="35" max="90" value="65">
            </div>
            <div class="num"><span id="roiVal">65</span>%</div>
          </div>

          <div class="sliderRow">
            <div>
              <div class="label">Línea de conteo (altura dentro del ROI)</div>
              <input id="lineY" type="range" min="15" max="85" value="55">
            </div>
            <div class="num"><span id="lineYVal">55</span>%</div>
          </div>

          <div class="sliderRow">
            <div>
              <div class="label">Sensibilidad (B2: umbral)</div>
              <input id="thr" type="range" min="3" max="30" value="14">
            </div>
            <div class="num"><span id="thrVal">0.14</span></div>
          </div>

          <div class="sliderRow">
            <div>
              <div class="label">Cooldown (ms)</div>
              <input id="cool" type="range" min="400" max="3000" value="1400">
            </div>
            <div class="num"><span id="coolVal">1400</span></div>
          </div>

          <div class="sliderRow">
            <div>
              <div class="label">B3: (Roboflow) área mínima (pata detectada)</div>
              <input id="minArea" type="range" min="300" max="6000" value="1600">
            </div>
            <div class="num"><span id="minAreaVal">1600</span></div>
          </div>

          <div class="mini">
            Umbral recomendado para tanque (B2): 0.10–0.16.  
            Si cuenta doble: sube cooldown.
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="camWrap">
        <video id="video" playsinline muted></video>
        <canvas id="cv"></canvas>
      </div>
    </div>

    <!-- DERECHA -->
    <div class="card">
      <h2>Bitácora (últimos eventos)</h2>
      <div class="row">
        <span class="tag"><strong id="logCount">0</strong> evento(s)</span>
        <span class="spacer"></span>
        <span class="tag blue"><strong>Hora local:</strong> <span id="clock">—</span></span>
      </div>

      <div class="hr"></div>

      <div class="log" id="log"></div>

      <div class="hr"></div>

      <div class="mini">
        iPhone: abre en Safari → “ACTIVAR CÁMARA”.  
        Si no pide permisos: Ajustes → Safari → Cámara → Permitir.
      </div>
    </div>
  </div>

  <!-- IMPORTANTE: ya no cargamos OpenCV -->
  <script type="module">
    import { InferenceEngine, CVImage } from "https://esm.sh/inferencejs";

    // ====== Roboflow (TU MODELO) ======
    // Si regeneras tu publishable, solo cambias aquí.
    const RF_PUBLISHABLE_KEY = "rf_cZVpt4nSGwabGVW3Fr0rzawLieC2";
    const RF_MODEL_SLUG = "vdc-patas";
    const RF_MODEL_VERSION = 2;

    // Roboflow engine
    const rfEngine = new InferenceEngine();
    let rfWorkerId = null;
    let rfReady = false;
    let rfLoading = false;

    // Ajustes B3 (puedes moverlos si quieres)
    const RF_CONFIDENCE = 0.65;   // confianza mínima
    const RF_INFER_MS = 220;      // cada cuánto inferimos (ms)

    // ====== Estado ======
    const LS_KEY = "vdc_patas_state_v3";
    let state = {
      count: 0,
      running: false,
      mode: "B2", // B2 | B3
      debug: false,
      sessionName: "",
      events: [],
      lastSaved: null,
      roiPct: 65,
      lineYPct: 55,
      thr: 0.14,
      cooldownMs: 1400,
      minArea: 1600,
      camera: { facingMode: "environment" } // or "user"
    };

    // ====== UI ======
    const $ = (id)=>document.getElementById(id);
    const flash = $("flash");
    const countEl = $("count");
    const logEl = $("log");
    const logCountEl = $("logCount");
    const savedText = $("savedText");
    const lastSavedEl = $("lastSaved");
    const runState = $("runState");
    const modeText = $("modeText");
    const dbgText = $("dbgText");
    const clockEl = $("clock");

    const video = $("video");
    const canvas = $("cv");
    const ctx = canvas.getContext("2d");

    // sliders
    const roi = $("roi"), lineY = $("lineY"), thr = $("thr"), cool = $("cool"), minArea = $("minArea");
    const roiVal = $("roiVal"), lineYVal = $("lineYVal"), thrVal = $("thrVal"), coolVal = $("coolVal"), minAreaVal = $("minAreaVal");

    // ====== Audio (beep) ======
    let audioCtx = null;
    function beep(){
      try{
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "sine";
        o.frequency.value = 880;
        g.gain.value = 0.06;
        o.connect(g); g.connect(audioCtx.destination);
        o.start();
        setTimeout(()=>{o.stop();}, 80);
      }catch(e){}
    }
    function vibrate(){
      try{ navigator.vibrate?.(60); }catch(e){}
    }

    // ====== Persistencia ======
    function load(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if(raw){
          const s = JSON.parse(raw);
          state = {...state, ...s};
        }
      }catch(e){}
      $("sessionName").value = state.sessionName || "";
      roi.value = state.roiPct; lineY.value = state.lineYPct;
      thr.value = Math.round(state.thr*100);
      cool.value = state.cooldownMs;
      minArea.value = state.minArea;
      updateUI();
      renderLog();
    }

    function save(){
      state.lastSaved = new Date().toISOString();
      localStorage.setItem(LS_KEY, JSON.stringify(state));
      savedText.textContent = "listo";
      lastSavedEl.textContent = fmtTime(state.lastSaved);
    }

    function autosave(){
      savedText.textContent = "guardando…";
      save();
    }

    function fmtTime(iso){
      try{
        const d = new Date(iso);
        return d.toLocaleString();
      }catch(e){ return "—"; }
    }

    // ====== Log ======
    function pushEvent(type, extra={}){
      const ev = {
        type,
        ts: new Date().toISOString(),
        count: state.count,
        mode: state.mode,
        ...extra
      };
      state.events.unshift(ev);
      state.events = state.events.slice(0, 80);
      autosave();
      renderLog();
    }

    function renderLog(){
      logEl.innerHTML = "";
      logCountEl.textContent = state.events.length;
      if(state.events.length === 0){
        logEl.innerHTML = `<div class="logItem"><b>Sin eventos</b><span class="right">Empieza con INICIAR</span></div>`;
        return;
      }
      for(const ev of state.events){
        const t = new Date(ev.ts).toLocaleString();
        const right = `Conteo ${ev.count}`;
        logEl.insertAdjacentHTML("beforeend", `
          <div class="logItem">
            <div>
              <b>${ev.type}</b>
              <div class="mini">${t} • ${ev.mode}${ev.note ? " • "+ev.note : ""}</div>
            </div>
            <div class="right">${right}</div>
          </div>
        `);
      }
    }

    // ====== UI State ======
    function updateUI(){
      countEl.textContent = state.count;
      runState.textContent = state.running ? "CORRIENDO" : "PAUSADO";
      modeText.textContent = state.mode;
      dbgText.textContent = state.debug ? "ON" : "OFF";
      lastSavedEl.textContent = state.lastSaved ? fmtTime(state.lastSaved) : "—";

      roiVal.textContent = state.roiPct;
      lineYVal.textContent = state.lineYPct;
      thrVal.textContent = (state.thr).toFixed(2);
      coolVal.textContent = state.cooldownMs;
      minAreaVal.textContent = state.minArea;
    }

    function flashGreen(){
      flash.classList.add("on");
      setTimeout(()=>flash.classList.remove("on"), 120);
    }

    function countedVisual(note=""){
      flashGreen();
      beep();
      vibrate();
      pushEvent("CONTEO +1", note ? {note} : {});
    }

    // ====== Controls ======
    $("btnStart").onclick = ()=>{
      state.running = true;
      autosave();
      pushEvent("INICIAR");
      updateUI();
    };
    $("btnPause").onclick = ()=>{
      state.running = false;
      autosave();
      pushEvent("PAUSAR");
      updateUI();
    };
    $("btnPlus").onclick = ()=>{
      state.count += 1;
      countedVisual("manual");
      updateUI();
    };
    $("btnUndo").onclick = ()=>{
      state.count = Math.max(0, state.count - 1);
      pushEvent("DESHACER");
      autosave();
      updateUI();
    };
    $("btnReset").onclick = ()=>{
      state.count = 0;
      pushEvent("REINICIAR");
      autosave();
      updateUI();
    };
    $("btnCSV").onclick = ()=>{
      const rows = [["ts","type","count","mode","note"]];
      for(const ev of [...state.events].reverse()){
        rows.push([ev.ts, ev.type, ev.count, ev.mode, ev.note || ""]);
      }
      const csv = rows.map(r=>r.map(v=>`"${String(v).replaceAll('"','""')}"`).join(",")).join("\n");
      const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = `vdc_patas_${(state.sessionName||"sesion").replaceAll(" ","_")}_${Date.now()}.csv`;
      a.click();
      URL.revokeObjectURL(a.href);
      pushEvent("EXPORTAR CSV");
    };

    $("sessionName").oninput = (e)=>{
      state.sessionName = e.target.value || "";
      autosave();
      updateUI();
    };

    $("btnDebug").onclick = ()=>{
      state.debug = !state.debug;
      pushEvent(state.debug ? "DEBUG ON" : "DEBUG OFF");
      autosave();
      updateUI();
    };

    $("btnMode").onclick = async ()=>{
      state.mode = (state.mode === "B2") ? "B3" : "B2";
      pushEvent("CAMBIO MODO", {note: state.mode});
      autosave();
      updateUI();

      // Si cambias a B3, intenta preparar Roboflow
      if(state.mode === "B3"){
        await ensureRoboflowReady();
      }
    };

    $("btnCalib").onclick = ()=>{
      if(state.mode !== "B2"){
        pushEvent("CALIBRAR", {note:"solo B2"});
        return;
      }
      calibrating = true;
      calibStart = performance.now();
      calibSamples = [];
      pushEvent("CALIBRAR", {note:"10s"});
    };

    // sliders bindings
    roi.oninput = ()=>{ state.roiPct = +roi.value; autosave(); updateUI(); };
    lineY.oninput = ()=>{ state.lineYPct = +lineY.value; autosave(); updateUI(); };
    thr.oninput = ()=>{ state.thr = (+thr.value)/100; autosave(); updateUI(); };
    cool.oninput = ()=>{ state.cooldownMs = +cool.value; autosave(); updateUI(); };
    minArea.oninput = ()=>{ state.minArea = +minArea.value; autosave(); updateUI(); };

    // ====== Camera ======
    let stream = null;
    let usingFront = false;

    $("btnFlip").onclick = async ()=>{
      usingFront = !usingFront;
      state.camera.facingMode = usingFront ? "user" : "environment";
      pushEvent("CAMBIO CÁMARA", {note: state.camera.facingMode});
      await stopCamera();
      await startCamera();
    };

    $("btnCamOn").onclick = async ()=>{
      await startCamera();
      // Si estás en B3, asegura Roboflow
      if(state.mode === "B3"){
        await ensureRoboflowReady();
      }
    };
    $("btnCamOff").onclick = async ()=>{
      await stopCamera();
      pushEvent("CAMARA_OFF");
    };

    async function startCamera(){
      try{
        if(stream) await stopCamera();
        const constraints = {
          audio:false,
          video:{
            facingMode: state.camera.facingMode,
            width: { ideal: 1280 },
            height:{ ideal: 720 }
          }
        };
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        await video.play();

        pushEvent("CAMARA_ON");
        autosave();
      }catch(err){
        pushEvent("CAMARA_ERROR", {note: String(err?.message || err)});
        alert("No se pudo activar cámara. Revisa permisos de Safari → Cámara → Permitir.");
      }
    }

    async function stopCamera(){
      try{
        if(video.srcObject){
          video.pause();
          video.srcObject = null;
        }
        if(stream){
          stream.getTracks().forEach(t=>t.stop());
          stream = null;
        }
      }catch(e){}
    }

    // ====== Vision Loop ======
    let lastCountAt = 0;

    // For B2 motion
    let lastFrame = null;
    let lastMetric = 0;

    // Calibration
    let calibrating = false;
    let calibStart = 0;
    let calibSamples = [];

    function ensureCanvas(){
      const w = video.videoWidth || 1280;
      const h = video.videoHeight || 720;
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
      }
    }

    function getROI(){
      const w = canvas.width, h = canvas.height;
      const pct = state.roiPct/100;
      const rw = Math.floor(w*pct);
      const rh = Math.floor(h*pct);
      const x = Math.floor((w - rw)/2);
      const y = Math.floor((h - rh)/2);
      return {x,y,rw,rh};
    }

    function drawOverlay(metricText=""){
      const {x,y,rw,rh} = getROI();
      const lineYLocal = y + Math.floor(rh*(state.lineYPct/100));

      // ROI
      ctx.lineWidth = 4;
      ctx.strokeStyle = "rgba(74,163,255,.75)";
      ctx.strokeRect(x,y,rw,rh);

      // line
      ctx.beginPath();
      ctx.moveTo(x, lineYLocal);
      ctx.lineTo(x+rw, lineYLocal);
      ctx.strokeStyle = "rgba(50,208,127,.85)";
      ctx.stroke();

      // debug
      if(state.debug){
        ctx.fillStyle = "rgba(0,0,0,.55)";
        ctx.fillRect(14, 14, 520, 120);
        ctx.fillStyle = "rgba(255,255,255,.92)";
        ctx.font = "bold 18px ui-sans-serif, system-ui";
        ctx.fillText(`Modo ${state.mode} • ${state.running ? "RUN" : "PAUSE"}`, 24, 42);
        ctx.font = "bold 16px ui-sans-serif, system-ui";
        ctx.fillText(metricText, 24, 70);
        ctx.font = "14px ui-sans-serif, system-ui";
        ctx.fillText(`thr=${state.thr.toFixed(2)} cool=${state.cooldownMs}ms minArea=${state.minArea}`, 24, 96);
        ctx.fillText(`RF conf>=${RF_CONFIDENCE} infer=${RF_INFER_MS}ms`, 24, 116);
      }
    }

    function canCount(){
      const now = performance.now();
      return (now - lastCountAt) > state.cooldownMs;
    }

    function doCount(note="auto"){
      if(!state.running) return;
      if(!canCount()) return;

      state.count += 1;
      lastCountAt = performance.now();
      autosave();
      updateUI();
      countedVisual(note);
    }

    // --- B2: motion metric inside ROI
    function stepB2(){
      const {x,y,rw,rh} = getROI();
      const frame = ctx.getImageData(x,y,rw,rh);

      if(lastFrame){
        const a = frame.data, b = lastFrame.data;
        let diff = 0;
        for(let i=0; i<a.length; i+=8){
          diff += Math.abs(a[i] - b[i]);
        }
        const norm = diff / ( (a.length/8) * 255 );
        lastMetric = norm;

        if(calibrating){
          calibSamples.push(norm);
          if(performance.now() - calibStart > 10000){
            calibrating = false;
            const base = calibSamples.sort((p,q)=>p-q);
            const p95 = base[Math.floor(base.length*0.95)] || 0.02;
            const newThr = Math.min(0.30, Math.max(0.06, p95*2.4 + 0.02));
            state.thr = +newThr.toFixed(2);
            thr.value = Math.round(state.thr*100);
            pushEvent("CALIBRAR OK", {note:`thr=${state.thr.toFixed(2)}`});
            autosave(); updateUI();
          }
        }

        if(state.running && norm > state.thr){
          doCount(`B2 motion ${norm.toFixed(2)}`);
        }
      }

      lastFrame = frame;
      drawOverlay(`B2 motion=${lastMetric.toFixed(3)} (sube al caer pata)`);
    }

    // ====== B3 Roboflow (detección + tracking + cruce de línea) ======
    let rfLastInferAt = 0;
    let tracks = [];
    let nextTrackId = 1;

    const TRACK_MAX_DIST = 120;      // px para asociar
    const TRACK_TTL_MS = 1400;       // si no se ve, se borra

    async function ensureRoboflowReady(){
      if(rfReady || rfLoading) return;
      rfLoading = true;
      try{
        pushEvent("B3 Roboflow", {note:"cargando modelo…"});
        rfWorkerId = await rfEngine.startWorker(RF_MODEL_SLUG, RF_MODEL_VERSION, RF_PUBLISHABLE_KEY);
        rfReady = true;
        pushEvent("B3 Roboflow listo", {note:`${RF_MODEL_SLUG}/${RF_MODEL_VERSION}`});
        autosave();
      }catch(e){
        pushEvent("B3 Roboflow error", {note:String(e?.message || e)});
      } finally {
        rfLoading = false;
      }
    }

    function updateTracks(dets, lineYLocal){
      const t = performance.now();

      // mark unseen
      for(const tr of tracks) tr._hit = false;

      for(const d of dets){
        let best = null, bestDist = Infinity;
        for(const tr of tracks){
          const dist = Math.hypot(d.cx - tr.cx, d.cy - tr.cy);
          if(dist < bestDist && dist < TRACK_MAX_DIST){
            bestDist = dist; best = tr;
          }
        }

        if(best){
          best._hit = true;
          best.lastSeen = t;
          best.prevCy = best.cy;
          best.cx = d.cx; best.cy = d.cy;
          best.area = d.area;
          best.conf = d.conf;
        }else{
          tracks.push({
            id: nextTrackId++,
            cx: d.cx, cy: d.cy,
            prevCy: d.cy,
            lastSeen: t,
            area: d.area,
            conf: d.conf,
            countedAt: 0
          });
          tracks[tracks.length-1]._hit = true;
        }
      }

      // remove old
      tracks = tracks.filter(tr => (t - tr.lastSeen) <= TRACK_TTL_MS);

      // count when crossing line (above->below) & not too recent
      for(const tr of tracks){
        const wasAbove = tr.prevCy < lineYLocal;
        const nowBelow = tr.cy >= lineYLocal;
        const crossed = wasAbove && nowBelow;

        if(crossed && state.running && canCount()){
          // filtro por área mínima para evitar falsos positivos
          if(tr.area >= state.minArea){
            doCount(`B3 RF cross id=${tr.id} conf=${Math.round(tr.conf*100)}%`);
            tr.countedAt = t;
          }
        }
      }
    }

    async function stepB3(){
      const {x,y,rw,rh} = getROI();
      const lineYLocal = y + Math.floor(rh*(state.lineYPct/100));

      let metricText = "B3 Roboflow…";

      if(!rfReady){
        metricText = "B3 Roboflow cargando…";
        drawOverlay(metricText);
        // intenta cargar si ya hay cámara
        if(video.readyState >= 2) await ensureRoboflowReady();
        return;
      }

      // throttle
      const now = performance.now();
      if(now - rfLastInferAt < RF_INFER_MS){
        drawOverlay("B3 Roboflow (esperando inferencia)...");
        return;
      }
      rfLastInferAt = now;

      try{
        const img = new CVImage(video);
        const result = await rfEngine.infer(rfWorkerId, img);

        const preds = (result?.predictions || [])
          .filter(p => (String(p.class||"").toLowerCase().includes("pata")))
          .filter(p => (p.confidence ?? 0) >= RF_CONFIDENCE)
          .map(p => {
            const bb = p.bbox || {};
            const cx = bb.x ?? 0, cy = bb.y ?? 0, w = bb.width ?? 0, h = bb.height ?? 0;
            const area = Math.max(0, w*h);
            const bx = cx - w/2, by = cy - h/2;
            return { conf: (p.confidence ?? 0), cx, cy, w, h, area, bx, by };
          })
          // opcional: solo detecciones dentro del ROI (centro dentro)
          .filter(d => d.cx >= x && d.cx <= x+rw && d.cy >= y && d.cy <= y+rh);

        // dibuja detecciones
        for(const d of preds){
          // área mínima también aquí
          if(d.area < state.minArea) continue;

          ctx.lineWidth = 4;
          ctx.strokeStyle = "rgba(168,85,247,.95)";
          ctx.strokeRect(d.bx, d.by, d.w, d.h);

          ctx.fillStyle = "rgba(0,0,0,.45)";
          ctx.fillRect(d.bx, Math.max(0, d.by-26), 170, 26);
          ctx.fillStyle = "rgba(255,255,255,.92)";
          ctx.font = "bold 16px ui-sans-serif, system-ui";
          ctx.fillText(`pata ${Math.round(d.conf*100)}%`, d.bx+8, Math.max(18, d.by-8));
        }

        // tracking + crossing
        const detsForTrack = preds.filter(d => d.area >= state.minArea);
        updateTracks(detsForTrack, lineYLocal);

        metricText = `B3 RF dets=${detsForTrack.length} tracks=${tracks.length}`;
      } catch(e){
        metricText = `B3 RF error: ${String(e?.message || e)}`;
      }

      drawOverlay(metricText);
    }

    // ====== Main Loop ======
    function loop(){
      requestAnimationFrame(loop);

      if(!video || video.readyState < 2) {
        clockEl.textContent = new Date().toLocaleTimeString();
        return;
      }

      ensureCanvas();
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      if(state.mode === "B2") stepB2();
      else stepB3();

      clockEl.textContent = new Date().toLocaleTimeString();
    }

    // ====== Boot ======
    load();
    loop();

    // autosave
    setInterval(()=>{ autosave(); }, 15000);
  </script>
</body>
</html>



