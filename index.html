<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VDC Contador de Patas — B2/B3/RF</title>

  <style>
    :root{
      --bg1:#08101f; --bg2:#060b16;
      --card: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.10);
      --text:#eaf0ff; --muted: rgba(234,240,255,.65);
      --green:#32d07f; --amber:#caa24a; --red:#e05555; --blue:#4aa3ff;
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh;
      background: radial-gradient(1200px 700px at 20% 10%, #0b2a5a 0%, var(--bg1) 45%, var(--bg2) 100%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      padding:18px;
    }
    .topbar{display:flex;align-items:center;gap:12px;margin-bottom:14px}
    .pill{
      display:inline-flex;align-items:center;gap:10px;
      padding:8px 12px;border:1px solid var(--stroke);
      background:rgba(0,0,0,.25);border-radius:999px;
      font-weight:700;letter-spacing:.3px
    }
    .dot{width:10px;height:10px;border-radius:50%;background:var(--green);box-shadow:0 0 14px rgba(50,208,127,.7)}
    h1{margin:0;font-size:22px}
    .sub{color:var(--muted);margin-top:4px;font-size:13px}

    .grid{display:grid;grid-template-columns: 1.25fr .95fr;gap:14px;align-items:start}
    @media(max-width:980px){.grid{grid-template-columns:1fr}}

    .card{
      border:1px solid var(--stroke);
      background:var(--card);
      border-radius:18px;
      padding:14px;
      box-shadow: 0 18px 50px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
    }
    .card h2{margin:0 0 10px 0;font-size:16px}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .spacer{flex:1}
    .btn{
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:12px 14px;border-radius:14px;
      font-weight:800;cursor:pointer;
      min-width:160px;text-align:center;
      user-select:none;
    }
    .btn:active{transform:scale(.99)}
    .btn.green{background:rgba(50,208,127,.22);border-color:rgba(50,208,127,.45)}
    .btn.amber{background:rgba(202,162,74,.22);border-color:rgba(202,162,74,.45)}
    .btn.red{background:rgba(224,85,85,.22);border-color:rgba(224,85,85,.45)}
    .btn.blue{background:rgba(74,163,255,.20);border-color:rgba(74,163,255,.42)}
    .btn.ghost{opacity:.65}
    .btn.full{width:100%}
    .btn.small{padding:10px 12px;min-width:unset}

    .big{
      font-size:84px;font-weight:900;line-height:1;letter-spacing:-2px;
      margin:10px 0 0 0;
    }
    .label{color:var(--muted);font-weight:700}
    .statusline{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .tag{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.18);
      font-weight:800;font-size:12px;color:var(--muted)
    }
    .tag strong{color:var(--text)}
    .tag.ok{border-color:rgba(50,208,127,.4)}
    .tag.warn{border-color:rgba(202,162,74,.4)}
    .tag.bad{border-color:rgba(224,85,85,.4)}
    .tag.blue{border-color:rgba(74,163,255,.4)}

    .field{
      width:100%;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.20);
      color:var(--text);
      font-weight:700;
      outline:none;
    }
    .mini{font-size:12px;color:var(--muted);margin-top:8px}

    .camWrap{position:relative;border-radius:18px;overflow:hidden;border:1px solid var(--stroke)}
    video{width:100%;display:block;background:#000;aspect-ratio: 16/9;object-fit:cover}
    canvas{position:absolute;inset:0;width:100%;height:100%;pointer-events:none}

    .flash{
      position:fixed;inset:0;pointer-events:none;
      background:rgba(50,208,127,.18);
      opacity:0;transition:opacity .12s ease;
    }
    .flash.on{opacity:1}
    .log{max-height:260px;overflow:auto;border-radius:14px;border:1px solid var(--stroke);padding:10px;background:rgba(0,0,0,.18)}
    .logItem{display:flex;justify-content:space-between;gap:10px;padding:8px 8px;border-bottom:1px solid rgba(255,255,255,.06)}
    .logItem:last-child{border-bottom:none}
    .logItem b{font-weight:900}
    .right{text-align:right;color:var(--muted);font-weight:800}
    .hr{height:1px;background:rgba(255,255,255,.08);margin:12px 0}
    .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media(max-width:980px){.two{grid-template-columns:1fr}}
    .sliderRow{display:grid;grid-template-columns:1fr 110px;gap:10px;align-items:center}
    input[type="range"]{width:100%}
    .num{padding:10px 10px;border-radius:12px;border:1px solid var(--stroke);background:rgba(0,0,0,.18);text-align:center;font-weight:900}
  </style>

  <!-- OpenCV (solo B3) -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <!-- Roboflow inferencejs (RF) -->
  <script src="https://cdn.jsdelivr.net/npm/inferencejs"></script>
</head>

<body>
  <div class="flash" id="flash"></div>

  <div class="topbar">
    <div class="pill"><span class="dot"></span>ONLINE</div>
    <div>
      <h1>VDC Contador de Patas</h1>
      <div class="sub">B2 (movimiento) + B3 (OpenCV) + RF (Roboflow IA real). Guardado local.</div>
    </div>
  </div>

  <div class="grid">
    <!-- IZQUIERDA -->
    <div class="card">
      <h2>Conteo</h2>

      <div class="row">
        <div>
          <div class="big" id="count">0</div>
          <div class="label">patas</div>
        </div>
        <div class="spacer"></div>

        <div style="min-width:280px">
          <input class="field" id="sessionName" placeholder="Nombre de sesión (opcional) Ej. Camión 7:00 AM - Martes">
          <div class="statusline">
            <span class="tag ok"><strong id="savedState">Guardado:</strong> <span id="savedText">listo</span></span>
            <span class="tag blue"><strong>Último:</strong> <span id="lastSaved">—</span></span>
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <div class="btn green" id="btnStart">INICIAR</div>
        <div class="btn ghost" id="btnPause">PAUSAR</div>
        <div class="btn amber" id="btnPlus">+1 PATA</div>
        <div class="btn ghost" id="btnUndo">DESHACER</div>
        <div class="btn red" id="btnReset">REINICIAR A CERO</div>
        <div class="btn blue" id="btnCSV">EXPORTAR (CSV)</div>
      </div>

      <div class="mini">
        Tip: iPhone fijo en tripié apuntando al tanque. En RF cuenta por IA.
      </div>

      <div class="hr"></div>

      <div class="two">
        <div class="card" style="padding:12px">
          <h2 style="margin:0 0 10px 0">Modo Cámara</h2>
          <div class="row">
            <button class="btn green small" id="btnCamOn">ACTIVAR CÁMARA</button>
            <button class="btn small" id="btnCamOff">APAGAR</button>
            <button class="btn small" id="btnFlip">CAMBIAR CÁMARA</button>
          </div>

          <div class="hr"></div>

          <div class="row">
            <span class="tag warn"><strong>Estado:</strong> <span id="runState">PAUSADO</span></span>
            <span class="tag blue"><strong>Modo:</strong> <span id="modeText">B2</span></span>
            <span class="tag"><strong>Debug:</strong> <span id="dbgText">OFF</span></span>
          </div>

          <div class="hr"></div>

          <div class="row">
            <button class="btn small blue" id="btnMode">CAMBIAR B2/B3/RF</button>
            <button class="btn small" id="btnDebug">DEBUG</button>
            <button class="btn small" id="btnCalib">CALIBRAR (10s)</button>
          </div>

          <div class="mini">
            B2 = movimiento (rápido, se confunde con sombras).<br/>
            B3 = OpenCV (respaldo).<br/>
            <b>RF = Roboflow IA real (recomendado)</b>.
          </div>
        </div>

        <div class="card" style="padding:12px">
          <h2 style="margin:0 0 10px 0">Ajustes (en vivo)</h2>

          <div class="sliderRow">
            <div>
              <div class="label">ROI (tamaño del cuadro)</div>
              <input id="roi" type="range" min="35" max="90" value="65">
            </div>
            <div class="num"><span id="roiVal">65</span>%</div>
          </div>

          <div class="sliderRow">
            <div>
              <div class="label">Línea de conteo (altura dentro del ROI)</div>
              <input id="lineY" type="range" min="15" max="85" value="55">
            </div>
            <div class="num"><span id="lineYVal">55</span>%</div>
          </div>

          <div class="sliderRow">
            <div>
              <div class="label">Sensibilidad (B2: umbral)</div>
              <input id="thr" type="range" min="3" max="30" value="14">
            </div>
            <div class="num"><span id="thrVal">0.14</span></div>
          </div>

          <div class="sliderRow">
            <div>
              <div class="label">Cooldown (ms)</div>
              <input id="cool" type="range" min="400" max="3000" value="1400">
            </div>
            <div class="num"><span id="coolVal">1400</span></div>
          </div>

          <div class="sliderRow">
            <div>
              <div class="label">B3: área mínima (objeto)</div>
              <input id="minArea" type="range" min="300" max="6000" value="1600">
            </div>
            <div class="num"><span id="minAreaVal">1600</span></div>
          </div>

          <div class="sliderRow">
            <div>
              <div class="label">RF: confianza mínima</div>
              <input id="rfConf" type="range" min="25" max="90" value="60">
            </div>
            <div class="num"><span id="rfConfVal">0.60</span></div>
          </div>

          <div class="sliderRow">
            <div>
              <div class="label">RF: FPS (requests/seg)</div>
              <input id="rfFps" type="range" min="1" max="6" value="3">
            </div>
            <div class="num"><span id="rfFpsVal">3</span></div>
          </div>

          <div class="mini">
            Recomendado RF: confianza 0.45–0.70 y FPS 2–4.<br/>
            Si no detecta: baja confianza y ajusta ROI.
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="camWrap">
        <video id="video" playsinline muted></video>
        <canvas id="cv"></canvas>
      </div>
    </div>

    <!-- DERECHA -->
    <div class="card">
      <h2>Bitácora (últimos eventos)</h2>
      <div class="row">
        <span class="tag"><strong id="logCount">0</strong> evento(s)</span>
        <span class="spacer"></span>
        <span class="tag blue"><strong>Hora local:</strong> <span id="clock">—</span></span>
      </div>

      <div class="hr"></div>
      <div class="log" id="log"></div>

      <div class="hr"></div>
      <div class="mini">
        iPhone: abre en Safari → “ACTIVAR CÁMARA”.<br/>
        Si no pide permisos: Ajustes → Safari → Cámara → Permitir.
      </div>
    </div>
  </div>

  <script>
    // ======================
    //  CONFIG ROBLOW (RF)
    // ======================
    const PUBLISHABLE_KEY = "rf_cZVpt4nSGwabGVW3Fr0rzawLieC2";

    // Según tu captura: marcianoper/vdc-patas-instant-4
    // inferencejs necesita (name, version). Dependiendo cómo quedó guardado en Roboflow,
    // la versión puede estar en 1 y el "-4" ser parte del nombre, o al revés.
    const MODEL_CANDIDATES = [
      { name: "vdc-patas-instant-4", version: 1 },
      { name: "vdc-patas-instant", version: 4 },
      { name: "vdc-patas", version: 2 }
    ];

    // ====== Estado ======
    const LS_KEY = "vdc_patas_state_v4";
    let state = {
      count: 0,
      running: false,
      mode: "B2", // B2 | B3 | RF
      debug: false,
      sessionName: "",
      events: [],
      lastSaved: null,
      roiPct: 65,
      lineYPct: 55,
      thr: 0.14,
      cooldownMs: 1400,
      minArea: 1600,
      rfConf: 0.60,
      rfFps: 3,
      camera: { facingMode: "environment" }
    };

    // ====== UI ======
    const $ = (id)=>document.getElementById(id);
    const flash = $("flash");
    const countEl = $("count");
    const logEl = $("log");
    const logCountEl = $("logCount");
    const savedText = $("savedText");
    const lastSavedEl = $("lastSaved");
    const runState = $("runState");
    const modeText = $("modeText");
    const dbgText = $("dbgText");
    const clockEl = $("clock");

    const video = $("video");
    const canvas = $("cv");
    const ctx = canvas.getContext("2d");

    // sliders
    const roi = $("roi"), lineY = $("lineY"), thr = $("thr"), cool = $("cool"), minArea = $("minArea");
    const rfConf = $("rfConf"), rfFps = $("rfFps");
    const roiVal = $("roiVal"), lineYVal = $("lineYVal"), thrVal = $("thrVal"), coolVal = $("coolVal"), minAreaVal = $("minAreaVal");
    const rfConfVal = $("rfConfVal"), rfFpsVal = $("rfFpsVal");

    // ====== Audio ======
    let audioCtx = null;
    function beep(){
      try{
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "sine";
        o.frequency.value = 880;
        g.gain.value = 0.06;
        o.connect(g); g.connect(audioCtx.destination);
        o.start();
        setTimeout(()=>{o.stop();}, 80);
      }catch(e){}
    }
    function vibrate(){ try{ navigator.vibrate?.(60); }catch(e){} }

    // ====== Persistencia ======
    function load(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if(raw){
          const s = JSON.parse(raw);
          state = {...state, ...s};
        }
      }catch(e){}

      $("sessionName").value = state.sessionName || "";
      roi.value = state.roiPct; lineY.value = state.lineYPct;
      thr.value = Math.round(state.thr*100);
      cool.value = state.cooldownMs;
      minArea.value = state.minArea;
      rfConf.value = Math.round(state.rfConf*100);
      rfFps.value = state.rfFps;

      updateUI();
      renderLog();
    }

    function save(){
      state.lastSaved = new Date().toISOString();
      localStorage.setItem(LS_KEY, JSON.stringify(state));
      savedText.textContent = "listo";
      lastSavedEl.textContent = fmtTime(state.lastSaved);
    }

    function autosave(){
      savedText.textContent = "guardando…";
      save();
    }

    function fmtTime(iso){
      try{
        const d = new Date(iso);
        return d.toLocaleString();
      }catch(e){ return "—"; }
    }

    // ====== Log ======
    function pushEvent(type, extra={}){
      const ev = {
        type,
        ts: new Date().toISOString(),
        count: state.count,
        mode: state.mode,
        ...extra
      };
      state.events.unshift(ev);
      state.events = state.events.slice(0, 160);
      autosave();
      renderLog();
    }

    function renderLog(){
      logEl.innerHTML = "";
      logCountEl.textContent = state.events.length;
      if(state.events.length === 0){
        logEl.innerHTML = `<div class="logItem"><b>Sin eventos</b><span class="right">Empieza con INICIAR</span></div>`;
        return;
      }
      for(const ev of state.events){
        const t = new Date(ev.ts).toLocaleString();
        const right = `Conteo ${ev.count}`;
        logEl.insertAdjacentHTML("beforeend", `
          <div class="logItem">
            <div>
              <b>${ev.type}</b>
              <div class="mini">${t} • ${ev.mode}${ev.note ? " • "+ev.note : ""}</div>
            </div>
            <div class="right">${right}</div>
          </div>
        `);
      }
    }

    // ====== UI ======
    function updateUI(){
      countEl.textContent = state.count;
      runState.textContent = state.running ? "CORRIENDO" : "PAUSADO";
      modeText.textContent = state.mode;
      dbgText.textContent = state.debug ? "ON" : "OFF";
      lastSavedEl.textContent = state.lastSaved ? fmtTime(state.lastSaved) : "—";

      roiVal.textContent = state.roiPct;
      lineYVal.textContent = state.lineYPct;
      thrVal.textContent = (state.thr).toFixed(2);
      coolVal.textContent = state.cooldownMs;
      minAreaVal.textContent = state.minArea;
      rfConfVal.textContent = (state.rfConf).toFixed(2);
      rfFpsVal.textContent = state.rfFps;
    }

    function flashGreen(){
      flash.classList.add("on");
      setTimeout(()=>flash.classList.remove("on"), 120);
    }

    function countedVisual(note=""){
      flashGreen();
      beep();
      vibrate();
      pushEvent("CONTEO +1", note ? {note} : {});
    }

    // ====== Controls ======
    $("btnStart").onclick = ()=>{
      state.running = true;
      autosave();
      pushEvent("INICIAR");
      updateUI();
    };
    $("btnPause").onclick = ()=>{
      state.running = false;
      autosave();
      pushEvent("PAUSAR");
      updateUI();
    };
    $("btnPlus").onclick = ()=>{
      state.count += 1;
      countedVisual("manual");
      updateUI();
    };
    $("btnUndo").onclick = ()=>{
      state.count = Math.max(0, state.count - 1);
      pushEvent("DESHACER");
      autosave();
      updateUI();
    };
    $("btnReset").onclick = ()=>{
      state.count = 0;
      pushEvent("REINICIAR");
      autosave();
      updateUI();
    };
    $("btnCSV").onclick = ()=>{
      const rows = [["ts","type","count","mode","note"]];
      for(const ev of [...state.events].reverse()){
        rows.push([ev.ts, ev.type, ev.count, ev.mode, ev.note || ""]);
      }
      const csv = rows.map(r=>r.map(v=>`"${String(v).replaceAll('"','""')}"`).join(",")).join("\n");
      const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = `vdc_patas_${(state.sessionName||"sesion").replaceAll(" ","_")}_${Date.now()}.csv`;
      a.click();
      URL.revokeObjectURL(a.href);
      pushEvent("EXPORTAR CSV");
    };

    $("sessionName").oninput = (e)=>{
      state.sessionName = e.target.value || "";
      autosave();
      updateUI();
    };

    $("btnDebug").onclick = ()=>{
      state.debug = !state.debug;
      pushEvent(state.debug ? "DEBUG ON" : "DEBUG OFF");
      autosave();
      updateUI();
    };

    $("btnMode").onclick = ()=>{
      state.mode = (state.mode === "B2") ? "B3" : (state.mode === "B3" ? "RF" : "B2");
      pushEvent("CAMBIO MODO", {note: state.mode});
      autosave();
      updateUI();
      if(state.mode === "RF") ensureRFWorker();
    };

    // sliders bindings
    roi.oninput = ()=>{ state.roiPct = +roi.value; autosave(); updateUI(); };
    lineY.oninput = ()=>{ state.lineYPct = +lineY.value; autosave(); updateUI(); };
    thr.oninput = ()=>{ state.thr = (+thr.value)/100; autosave(); updateUI(); };
    cool.oninput = ()=>{ state.cooldownMs = +cool.value; autosave(); updateUI(); };
    minArea.oninput = ()=>{ state.minArea = +minArea.value; autosave(); updateUI(); };
    rfConf.oninput = ()=>{ state.rfConf = (+rfConf.value)/100; autosave(); updateUI(); };
    rfFps.oninput = ()=>{ state.rfFps = +rfFps.value; autosave(); updateUI(); };

    // ====== Camera ======
    let stream = null;
    let usingFront = false;

    $("btnFlip").onclick = async ()=>{
      usingFront = !usingFront;
      state.camera.facingMode = usingFront ? "user" : "environment";
      pushEvent("CAMBIO CÁMARA", {note: state.camera.facingMode});
      await stopCamera();
      await startCamera();
    };

    $("btnCamOn").onclick = async ()=>{ await startCamera(); };
    $("btnCamOff").onclick = async ()=>{ await stopCamera(); pushEvent("CAMARA_OFF"); };

    async function startCamera(){
      try{
        if(stream) await stopCamera();
        const constraints = {
          audio:false,
          video:{
            facingMode: state.camera.facingMode,
            width: { ideal: 1280 },
            height:{ ideal: 720 }
          }
        };
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        await video.play();

        pushEvent("CAMARA_ON");
        autosave();

        if(state.mode === "RF") ensureRFWorker();
      }catch(err){
        pushEvent("CAMARA_ERROR", {note: String(err?.message || err)});
        alert("No se pudo activar cámara. Revisa permisos de Safari → Cámara → Permitir.");
      }
    }

    async function stopCamera(){
      try{
        if(video.srcObject){
          video.pause();
          video.srcObject = null;
        }
        if(stream){
          stream.getTracks().forEach(t=>t.stop());
          stream = null;
        }
      }catch(e){}
    }

    // ====== Vision Helpers ======
    let lastCountAt = 0;
    function canCount(){
      const now = performance.now();
      return (now - lastCountAt) > state.cooldownMs;
    }
    function doCount(note="auto"){
      if(!state.running) return;
      if(!canCount()) return;

      state.count += 1;
      lastCountAt = performance.now();
      autosave();
      updateUI();
      countedVisual(note);
    }

    function ensureCanvas(){
      const w = video.videoWidth || 1280;
      const h = video.videoHeight || 720;
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
      }
    }

    function getROI(){
      const w = canvas.width, h = canvas.height;
      const pct = state.roiPct/100;
      const rw = Math.floor(w*pct);
      const rh = Math.floor(h*pct);
      const x = Math.floor((w - rw)/2);
      const y = Math.floor((h - rh)/2);
      return {x,y,rw,rh};
    }

    function drawOverlay(metricText=""){
      const {x,y,rw,rh} = getROI();
      const lineYLocal = y + Math.floor(rh*(state.lineYPct/100));

      // ROI
      ctx.lineWidth = 4;
      ctx.strokeStyle = "rgba(74,163,255,.75)";
      ctx.strokeRect(x,y,rw,rh);

      // line
      ctx.beginPath();
      ctx.moveTo(x, lineYLocal);
      ctx.lineTo(x+rw, lineYLocal);
      ctx.strokeStyle = "rgba(50,208,127,.85)";
      ctx.stroke();

      if(state.debug){
        ctx.fillStyle = "rgba(0,0,0,.55)";
        ctx.fillRect(14, 14, 720, 120);
        ctx.fillStyle = "rgba(255,255,255,.92)";
        ctx.font = "bold 18px ui-sans-serif, system-ui";
        ctx.fillText(`Modo ${state.mode} • ${state.running ? "RUN" : "PAUSE"}`, 24, 42);
        ctx.font = "bold 16px ui-sans-serif, system-ui";
        ctx.fillText(metricText, 24, 70);
        ctx.font = "14px ui-sans-serif, system-ui";
        ctx.fillText(`thr=${state.thr.toFixed(2)} cool=${state.cooldownMs}ms RFconf=${state.rfConf.toFixed(2)} RFfps=${state.rfFps}`, 24, 96);
      }
    }

    // ======================
    // B2: motion metric
    // ======================
    let lastFrame = null;
    let lastMetric = 0;
    let calibrating = false;
    let calibStart = 0;
    let calibSamples = [];

    $("btnCalib").onclick = ()=>{
      if(state.mode !== "B2"){
        pushEvent("CALIBRAR", {note:"solo B2"});
        return;
      }
      calibrating = true;
      calibStart = performance.now();
      calibSamples = [];
      pushEvent("CALIBRAR", {note:"10s"});
    };

    function stepB2(){
      const {x,y,rw,rh} = getROI();
      const frame = ctx.getImageData(x,y,rw,rh);

      if(lastFrame){
        const a = frame.data, b = lastFrame.data;
        let diff = 0;
        for(let i=0; i<a.length; i+=8){
          diff += Math.abs(a[i] - b[i]);
        }
        const norm = diff / ( (a.length/8) * 255 );
        lastMetric = norm;

        if(calibrating){
          calibSamples.push(norm);
          if(performance.now() - calibStart > 10000){
            calibrating = false;
            const base = calibSamples.sort((p,q)=>p-q);
            const p95 = base[Math.floor(base.length*0.95)] || 0.02;
            const newThr = Math.min(0.30, Math.max(0.06, p95*2.4 + 0.02));
            state.thr = +newThr.toFixed(2);
            thr.value = Math.round(state.thr*100);
            pushEvent("CALIBRAR OK", {note:`thr=${state.thr.toFixed(2)}`});
            autosave(); updateUI();
          }
        }

        if(state.running && norm > state.thr){
          doCount(`B2 motion ${norm.toFixed(2)}`);
        }
      }

      lastFrame = frame;
      drawOverlay(`B2 motion=${lastMetric.toFixed(3)} (ojo: sombras cuentan)`);
    }

    // ======================
    // B3: OpenCV
    // ======================
    let cvReady = false;
    let bgsub = null;
    let kernel = null;
    let lastCross = false;

    function initCVIfNeeded(){
      if(cvReady) return true;
      if(typeof cv === "undefined" || !cv.Mat) return false;

      try{
        bgsub = new cv.BackgroundSubtractorMOG2(300, 16, false);
        kernel = cv.Mat.ones(5,5, cv.CV_8U);
        cvReady = true;
        pushEvent("B3 OpenCV listo");
        autosave();
        return true;
      }catch(e){
        pushEvent("B3 OpenCV error", {note:String(e)});
        return false;
      }
    }

    function stepB3(){
      const ok = initCVIfNeeded();
      const {x,y,rw,rh} = getROI();
      const lineYLocal = y + Math.floor(rh*(state.lineYPct/100));
      let metricText = "B3 cargando OpenCV…";
      if(!ok){
        drawOverlay(metricText);
        return;
      }

      const img = ctx.getImageData(0,0,canvas.width,canvas.height);
      const src = cv.matFromImageData(img);

      const rect = new cv.Rect(x,y,rw,rh);
      const roiMat = src.roi(rect);

      const fg = new cv.Mat();
      bgsub.apply(roiMat, fg);

      cv.medianBlur(fg, fg, 5);
      cv.threshold(fg, fg, 200, 255, cv.THRESH_BINARY);
      cv.morphologyEx(fg, fg, cv.MORPH_OPEN, kernel);

      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(fg, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      let best = null;
      let bestArea = 0;
      for(let i=0;i<contours.size();i++){
        const c = contours.get(i);
        const area = cv.contourArea(c);
        if(area > bestArea){ bestArea = area; best = c; }
      }

      if(best && bestArea >= state.minArea){
        const r = cv.boundingRect(best);
        const gx = x + r.x, gy = y + r.y, gw = r.width, gh = r.height;
        const cx = gx + gw/2, cy = gy + gh/2;

        ctx.lineWidth = 4;
        ctx.strokeStyle = "rgba(202,162,74,.95)";
        ctx.strokeRect(gx,gy,gw,gh);
        ctx.beginPath(); ctx.arc(cx,cy,8,0,Math.PI*2);
        ctx.fillStyle = "rgba(202,162,74,.95)"; ctx.fill();

        const nowBelow = (cy >= lineYLocal);
        const crossed = (!lastCross && nowBelow);
        lastCross = nowBelow;

        metricText = `B3 area=${Math.round(bestArea)} cy=${Math.round(cy)} lineY=${lineYLocal}`;
        if(state.running && crossed){
          doCount(`B3 cross area=${Math.round(bestArea)}`);
        }
      }else{
        metricText = `B3 sin objeto (bestArea=${Math.round(bestArea)})`;
        lastCross = false;
      }

      src.delete(); roiMat.delete(); fg.delete(); contours.delete(); hierarchy.delete();
      drawOverlay(metricText);
    }

    // ======================
    // RF: Roboflow (inferencejs)
    // ======================
    let rfEngine = null;
    let rfWorkerId = null;
    let rfInFlight = false;
    let rfLastInferAt = 0;
    let rfLastBelow = false;

    const roiCanvas = document.createElement("canvas");
    const roiCtx = roiCanvas.getContext("2d");

    function getRFExports(){
      const lib = window.inferencejs ?? window;
      return {
        InferenceEngine: lib.InferenceEngine ?? window.InferenceEngine,
        CVImage: lib.CVImage ?? window.CVImage
      };
    }

    async function ensureRFWorker(){
      try{
        const { InferenceEngine } = getRFExports();
        pushEvent("RF LIB", {note:`InferenceEngine=${!!InferenceEngine}`});

        if(!InferenceEngine){
          pushEvent("RF error", {note:"InferenceEngine no existe. inferencejs no cargó/bloqueado."});
          return;
        }
        if(rfWorkerId) return;

        rfEngine = rfEngine || new InferenceEngine();

        for(const c of MODEL_CANDIDATES){
          try{
            pushEvent("RF probando modelo…", {note:`${c.name}/${c.version}`});
            rfWorkerId = await rfEngine.startWorker(c.name, c.version, PUBLISHABLE_KEY);
            pushEvent("RF listo", {note:`OK: ${c.name}/${c.version}`});
            autosave();
            return;
          }catch(eTry){
            pushEvent("RF fallo modelo", {note:`${c.name}/${c.version} -> ${String(eTry?.message || eTry)}`});
          }
        }

        pushEvent("RF error", {note:"No se pudo iniciar el worker con ningún candidato."});
      }catch(e){
        pushEvent("RF startWorker error", {note:String(e?.message || e)});
      }
    }

    function rfShouldInfer(){
      const now = performance.now();
      const interval = 1000 / Math.max(1, state.rfFps);
      return (now - rfLastInferAt) >= interval;
    }

    async function stepRF(){
      await ensureRFWorker();
      if(!rfWorkerId || !rfEngine){
        drawOverlay("RF no inicializado (revisa bitácora)");
        return;
      }
      if(rfInFlight || !rfShouldInfer()){
        drawOverlay("RF throttling…");
        return;
      }

      const {x,y,rw,rh} = getROI();
      const lineYLocal = y + Math.floor(rh*(state.lineYPct/100));

      roiCanvas.width = rw;
      roiCanvas.height = rh;
      roiCtx.drawImage(canvas, x, y, rw, rh, 0, 0, rw, rh);

      rfInFlight = true;
      rfLastInferAt = performance.now();

      try{
        const preds = await rfEngine.infer(rfWorkerId, roiCanvas);

        let best = null;
        let bestScore = 0;

        if(Array.isArray(preds)){
          for(const p of preds){
            const conf = Number(p.confidence ?? p.score ?? 0);

            // TEMP: sin filtro de clase para depurar
            // const cls = (p.class || p.label || "").toString().toLowerCase();
            // if(cls && !cls.includes("pata")) continue;

            if(conf > bestScore){
              bestScore = conf;
              best = p;
            }
          }
        }

        if(best){
          const bb = best.bbox || best.bounding_box || best.box || null;

          // algunos devuelven bbox anidado, otros top-level
          const bx = Number(bb?.x ?? best.x ?? 0);
          const by = Number(bb?.y ?? best.y ?? 0);
          const bw = Number(bb?.width ?? best.width ?? 0);
          const bh = Number(bb?.height ?? best.height ?? 0);

          // centro -> esquina
          const gx = x + (bx - bw/2);
          const gy = y + (by - bh/2);

          ctx.lineWidth = 4;
          ctx.strokeStyle = "rgba(202,162,74,.95)";
          ctx.strokeRect(gx, gy, bw, bh);

          const cx = gx + bw/2;
          const cy = gy + bh/2;

          ctx.beginPath();
          ctx.arc(cx, cy, 8, 0, Math.PI*2);
          ctx.fillStyle = "rgba(202,162,74,.95)";
          ctx.fill();

          const nowBelow = (cy >= lineYLocal);
          const crossed = (!rfLastBelow && nowBelow);
          rfLastBelow = nowBelow;

          drawOverlay(`RF conf=${bestScore.toFixed(2)} cy=${Math.round(cy)} lineY=${lineYLocal} preds=${preds?.length||0}`);

          if(bestScore >= state.rfConf && state.running && crossed){
            doCount(`RF cross conf=${bestScore.toFixed(2)}`);
          }
        }else{
          rfLastBelow = false;
          drawOverlay(`RF sin detección (conf≥${state.rfConf.toFixed(2)})`);
        }
      }catch(e){
        pushEvent("RF infer error", {note:String(e?.message || e)});
        drawOverlay("RF infer error (ver bitácora)");
      }finally{
        rfInFlight = false;
      }
    }

    // ====== Main Loop ======
    function loop(){
      requestAnimationFrame(loop);

      if(!video || video.readyState < 2) {
        clockEl.textContent = new Date().toLocaleTimeString();
        return;
      }

      ensureCanvas();
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      if(state.mode === "B2") stepB2();
      else if(state.mode === "B3") stepB3();
      else stepRF();

      clockEl.textContent = new Date().toLocaleTimeString();
    }

    // ====== Boot ======
    load();
    loop();
    setInterval(()=>{ autosave(); }, 15000);
  </script>
</body>
</html>
