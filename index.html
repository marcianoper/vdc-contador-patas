<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VDC Contador de Patas — B2/B3/RF</title>

  <style>
    :root{
      --bg1:#08101f; --bg2:#060b16;
      --card: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.10);
      --text:#eaf0ff; --muted: rgba(234,240,255,.65);
      --green:#32d07f; --amber:#caa24a; --red:#e05555; --blue:#4aa3ff;
      --purple:#a78bfa;
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh;
      background: radial-gradient(1200px 700px at 20% 10%, #0b2a5a 0%, var(--bg1) 45%, var(--bg2) 100%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      padding:18px;
    }
    .topbar{display:flex;align-items:center;gap:12px;margin-bottom:14px}
    .pill{
      display:inline-flex;align-items:center;gap:10px;
      padding:8px 12px;border:1px solid var(--stroke);
      background:rgba(0,0,0,.25);border-radius:999px;
      font-weight:700;letter-spacing:.3px
    }
    .dot{width:10px;height:10px;border-radius:50%;background:var(--green);box-shadow:0 0 14px rgba(50,208,127,.7)}
    h1{margin:0;font-size:22px}
    .sub{color:var(--muted);margin-top:4px;font-size:13px}

    .grid{display:grid;grid-template-columns: 1.25fr .95fr;gap:14px;align-items:start}
    @media(max-width:980px){.grid{grid-template-columns:1fr}}

    .card{
      border:1px solid var(--stroke);
      background:var(--card);
      border-radius:18px;
      padding:14px;
      box-shadow: 0 18px 50px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
    }
    .card h2{margin:0 0 10px 0;font-size:16px}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .spacer{flex:1}
    .btn{
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:12px 14px;border-radius:14px;
      font-weight:800;cursor:pointer;
      min-width:160px;text-align:center;
      user-select:none;
    }
    .btn:active{transform:scale(.99)}
    .btn.green{background:rgba(50,208,127,.22);border-color:rgba(50,208,127,.45)}
    .btn.amber{background:rgba(202,162,74,.22);border-color:rgba(202,162,74,.45)}
    .btn.red{background:rgba(224,85,85,.22);border-color:rgba(224,85,85,.45)}
    .btn.blue{background:rgba(74,163,255,.20);border-color:rgba(74,163,255,.42)}
    .btn.purple{background:rgba(167,139,250,.18);border-color:rgba(167,139,250,.40)}
    .btn.ghost{opacity:.65}
    .btn.full{width:100%}
    .btn.small{padding:10px 12px;min-width:unset}

    .big{
      font-size:84px;font-weight:900;line-height:1;letter-spacing:-2px;
      margin:10px 0 0 0;
    }
    .label{color:var(--muted);font-weight:700}
    .statusline{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .tag{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.18);
      font-weight:800;font-size:12px;color:var(--muted)
    }
    .tag strong{color:var(--text)}
    .tag.ok{border-color:rgba(50,208,127,.4)}
    .tag.warn{border-color:rgba(202,162,74,.4)}
    .tag.bad{border-color:rgba(224,85,85,.4)}
    .tag.blue{border-color:rgba(74,163,255,.4)}
    .tag.purple{border-color:rgba(167,139,250,.45)}

    .field{
      width:100%;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.20);
      color:var(--text);
      font-weight:700;
      outline:none;
    }
    .mini{font-size:12px;color:var(--muted);margin-top:8px}

    .camWrap{position:relative;border-radius:18px;overflow:hidden;border:1px solid var(--stroke)}
    video{width:100%;display:block;background:#000;aspect-ratio: 16/9;object-fit:cover}
    canvas{position:absolute;inset:0;width:100%;height:100%;pointer-events:none}

    .flash{
      position:fixed;inset:0;pointer-events:none;
      background:rgba(50,208,127,.18);
      opacity:0;transition:opacity .12s ease;
    }
    .flash.on{opacity:1}
    .log{max-height:260px;overflow:auto;border-radius:14px;border:1px solid var(--stroke);padding:10px;background:rgba(0,0,0,.18)}
    .logItem{display:flex;justify-content:space-between;gap:10px;padding:8px 8px;border-bottom:1px solid rgba(255,255,255,.06)}
    .logItem:last-child{border-bottom:none}
    .logItem b{font-weight:900}
    .right{text-align:right;color:var(--muted);font-weight:800}
    .hr{height:1px;background:rgba(255,255,255,.08);margin:12px 0}
    .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media(max-width:980px){.two{grid-template-columns:1fr}}
    .sliderRow{display:grid;grid-template-columns:1fr 110px;gap:10px;align-items:center}
    input[type="range"]{width:100%}
    .num{padding:10px 10px;border-radius:12px;border:1px solid var(--stroke);background:rgba(0,0,0,.18);text-align:center;font-weight:900}
  </style>

  <!-- OpenCV (solo se usa en B3) -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <!-- Roboflow inferencejs (B4/RF) -->
  <script type="module">
    import { InferenceEngine, CVImage } from "https://unpkg.com/inferencejs@0.9.17/dist/inferencejs.esm.js";
    window.__RF__ = { InferenceEngine, CVImage };
  </script>
</head>

<body>
  <div class="flash" id="flash"></div>

  <div class="topbar">
    <div class="pill"><span class="dot"></span>ONLINE</div>
    <div>
      <h1>VDC Contador de Patas</h1>
      <div class="sub">B2 (movimiento) + B3 (OpenCV) + RF (Roboflow en vivo). Guardado local.</div>
    </div>
  </div>

  <div class="grid">
    <!-- IZQUIERDA -->
    <div class="card">
      <h2>Conteo</h2>

      <div class="row">
        <div>
          <div class="big" id="count">0</div>
          <div class="label">patas</div>
        </div>
        <div class="spacer"></div>

        <div style="min-width:280px">
          <input class="field" id="sessionName" placeholder="Nombre de sesión (opcional) Ej. Camión 7:00 AM - Martes">
          <div class="statusline">
            <span class="tag ok"><strong id="savedState">Guardado:</strong> <span id="savedText">listo</span></span>
            <span class="tag blue"><strong>Último:</strong> <span id="lastSaved">—</span></span>
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <div class="btn green" id="btnStart">INICIAR</div>
        <div class="btn ghost" id="btnPause">PAUSAR</div>
        <div class="btn amber" id="btnPlus">+1 PATA</div>
        <div class="btn ghost" id="btnUndo">DESHACER</div>
        <div class="btn red" id="btnReset">REINICIAR A CERO</div>
        <div class="btn blue" id="btnCSV">EXPORTAR (CSV)</div>
      </div>

      <div class="mini">
        Tip: iPhone fijo en tripié apuntando al tanque/mesa. Cuenta cuando la pata entra al ROI y cruza la línea.
      </div>

      <div class="hr"></div>

      <div class="two">
        <div class="card" style="padding:12px">
          <h2 style="margin:0 0 10px 0">Modo Cámara</h2>
          <div class="row">
            <button class="btn green small" id="btnCamOn">ACTIVAR CÁMARA</button>
            <button class="btn small" id="btnCamOff">APAGAR</button>
            <button class="btn small" id="btnFlip">CAMBIAR CÁMARA</button>
          </div>

          <div class="hr"></div>

          <div class="row">
            <span class="tag warn"><strong>Estado:</strong> <span id="runState">PAUSADO</span></span>
            <span class="tag blue"><strong>Modo:</strong> <span id="modeText">B2</span></span>
            <span class="tag"><strong>Debug:</strong> <span id="dbgText">OFF</span></span>
          </div>

          <div class="hr"></div>

          <div class="row">
            <button class="btn small purple" id="btnMode">CAMBIAR MODO</button>
            <button class="btn small" id="btnDebug">DEBUG</button>
            <button class="btn small" id="btnCalib">CALIBRAR (10s)</button>
          </div>

          <div class="mini">
            B2 = movimiento (rápido). B3 = OpenCV (respaldo). RF = Roboflow (IA real).  
            Si RF va lento: baja FPS o sube confianza.
          </div>
        </div>

        <div class="card" style="padding:12px">
          <h2 style="margin:0 0 10px 0">Ajustes (en vivo)</h2>

          <div class="sliderRow">
            <div>
              <div class="label">ROI (tamaño del cuadro)</div>
              <input id="roi" type="range" min="35" max="90" value="65">
            </div>
            <div class="num"><span id="roiVal">65</span>%</div>
          </div>

          <div class="sliderRow">
            <div>
              <div class="label">Línea de conteo (altura dentro del ROI)</div>
              <input id="lineY" type="range" min="15" max="85" value="55">
            </div>
            <div class="num"><span id="lineYVal">55</span>%</div>
          </div>

          <div class="sliderRow">
            <div>
              <div class="label">Sensibilidad (B2: umbral)</div>
              <input id="thr" type="range" min="3" max="30" value="14">
            </div>
            <div class="num"><span id="thrVal">0.14</span></div>
          </div>

          <div class="sliderRow">
            <div>
              <div class="label">Cooldown (ms)</div>
              <input id="cool" type="range" min="400" max="3000" value="1400">
            </div>
            <div class="num"><span id="coolVal">1400</span></div>
          </div>

          <div class="sliderRow">
            <div>
              <div class="label">RF: confianza mínima</div>
              <input id="rfConf" type="range" min="30" max="95" value="60">
            </div>
            <div class="num"><span id="rfConfVal">0.60</span></div>
          </div>

          <div class="sliderRow">
            <div>
              <div class="label">RF: FPS (requests/seg)</div>
              <input id="rfFps" type="range" min="1" max="8" value="3">
            </div>
            <div class="num"><span id="rfFpsVal">3</span></div>
          </div>

          <div class="mini">
            Recomendado RF: confianza 0.55–0.75 y FPS 2–4.  
            Si cuenta doble: sube cooldown. Si no detecta: baja confianza o ajusta ROI.
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="camWrap">
        <video id="video" playsinline muted></video>
        <canvas id="cv"></canvas>
      </div>
    </div>

    <!-- DERECHA -->
    <div class="card">
      <h2>Bitácora (últimos eventos)</h2>
      <div class="row">
        <span class="tag"><strong id="logCount">0</strong> evento(s)</span>
        <span class="spacer"></span>
        <span class="tag blue"><strong>Hora local:</strong> <span id="clock">—</span></span>
      </div>

      <div class="hr"></div>
      <div class="log" id="log"></div>

      <div class="hr"></div>

      <div class="mini">
        iPhone: abre en Safari → “ACTIVAR CÁMARA”.  
        Si no pide permisos: Ajustes → Safari → Cámara → Permitir.
      </div>
    </div>
  </div>

  <script>
    // ====== Roboflow config ======
    const ROBOFLOW_PUBLISHABLE_KEY = "rf_cZVpt4nSGwabGVW3Fr0rzawLieC2";
    const ROBOFLOW_MODEL_ID = "vdc-patas/2"; // tu modelo

    // ====== Estado ======
    const LS_KEY = "vdc_patas_state_v4_rf";
    let state = {
      count: 0,
      running: false,
      mode: "B2", // B2 | B3 | RF
      debug: false,
      sessionName: "",
      events: [],
      lastSaved: null,
      roiPct: 65,
      lineYPct: 55,
      thr: 0.14,
      cooldownMs: 1400,
      rfConf: 0.60,
      rfFps: 3,
      camera: { facingMode: "environment" }
    };

    const $ = (id)=>document.getElementById(id);
    const flash = $("flash");
    const countEl = $("count");
    const logEl = $("log");
    const logCountEl = $("logCount");
    const savedText = $("savedText");
    const lastSavedEl = $("lastSaved");
    const runState = $("runState");
    const modeText = $("modeText");
    const dbgText = $("dbgText");
    const clockEl = $("clock");

    const video = $("video");
    const canvas = $("cv");
    const ctx = canvas.getContext("2d", { willReadFrequently:true });

    const roi = $("roi"), lineY = $("lineY"), thr = $("thr"), cool = $("cool"), rfConf = $("rfConf"), rfFps = $("rfFps");
    const roiVal = $("roiVal"), lineYVal = $("lineYVal"), thrVal = $("thrVal"), coolVal = $("coolVal"), rfConfVal = $("rfConfVal"), rfFpsVal = $("rfFpsVal");

    // ====== Audio (beep) ======
    let audioCtx = null;
    function beep(){
      try{
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "sine";
        o.frequency.value = 880;
        g.gain.value = 0.06;
        o.connect(g); g.connect(audioCtx.destination);
        o.start();
        setTimeout(()=>{o.stop();}, 80);
      }catch(e){}
    }
    function vibrate(){ try{ navigator.vibrate?.(60); }catch(e){} }

    // ====== Persistencia ======
    function load(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if(raw){
          const s = JSON.parse(raw);
          state = {...state, ...s};
        }
      }catch(e){}
      $("sessionName").value = state.sessionName || "";
      roi.value = state.roiPct; lineY.value = state.lineYPct;
      thr.value = Math.round(state.thr*100);
      cool.value = state.cooldownMs;
      rfConf.value = Math.round(state.rfConf*100);
      rfFps.value = state.rfFps;
      updateUI();
      renderLog();
    }

    function save(){
      state.lastSaved = new Date().toISOString();
      localStorage.setItem(LS_KEY, JSON.stringify(state));
      savedText.textContent = "listo";
      lastSavedEl.textContent = fmtTime(state.lastSaved);
    }

    function autosave(){
      savedText.textContent = "guardando…";
      save();
    }

    function fmtTime(iso){
      try{
        const d = new Date(iso);
        return d.toLocaleString();
      }catch(e){ return "—"; }
    }

    // ====== Log ======
    function pushEvent(type, extra={}){
      const ev = {
        type,
        ts: new Date().toISOString(),
        count: state.count,
        mode: state.mode,
        ...extra
      };
      state.events.unshift(ev);
      state.events = state.events.slice(0, 80);
      autosave();
      renderLog();
    }

    function renderLog(){
      logEl.innerHTML = "";
      logCountEl.textContent = state.events.length;
      if(state.events.length === 0){
        logEl.innerHTML = `<div class="logItem"><b>Sin eventos</b><span class="right">Empieza con INICIAR</span></div>`;
        return;
      }
      for(const ev of state.events){
        const t = new Date(ev.ts).toLocaleString();
        const right = `Conteo ${ev.count}`;
        logEl.insertAdjacentHTML("beforeend", `
          <div class="logItem">
            <div>
              <b>${ev.type}</b>
              <div class="mini">${t} • ${ev.mode}${ev.note ? " • "+ev.note : ""}</div>
            </div>
            <div class="right">${right}</div>
          </div>
        `);
      }
    }

    // ====== UI State ======
    function updateUI(){
      countEl.textContent = state.count;
      runState.textContent = state.running ? "CORRIENDO" : "PAUSADO";
      modeText.textContent = state.mode;
      dbgText.textContent = state.debug ? "ON" : "OFF";
      lastSavedEl.textContent = state.lastSaved ? fmtTime(state.lastSaved) : "—";

      roiVal.textContent = state.roiPct;
      lineYVal.textContent = state.lineYPct;
      thrVal.textContent = (state.thr).toFixed(2);
      coolVal.textContent = state.cooldownMs;
      rfConfVal.textContent = (state.rfConf).toFixed(2);
      rfFpsVal.textContent = state.rfFps;
    }

    function flashGreen(){
      flash.classList.add("on");
      setTimeout(()=>flash.classList.remove("on"), 120);
    }

    function countedVisual(note=""){
      flashGreen();
      beep();
      vibrate();
      pushEvent("CONTEO +1", note ? {note} : {});
    }

    // ====== Controls ======
    $("btnStart").onclick = ()=>{
      state.running = true;
      autosave();
      pushEvent("INICIAR");
      updateUI();
    };
    $("btnPause").onclick = ()=>{
      state.running = false;
      autosave();
      pushEvent("PAUSAR");
      updateUI();
    };
    $("btnPlus").onclick = ()=>{
      state.count += 1;
      countedVisual("manual");
      updateUI();
    };
    $("btnUndo").onclick = ()=>{
      state.count = Math.max(0, state.count - 1);
      pushEvent("DESHACER");
      autosave();
      updateUI();
    };
    $("btnReset").onclick = ()=>{
      state.count = 0;
      pushEvent("REINICIAR");
      autosave();
      updateUI();
    };
    $("btnCSV").onclick = ()=>{
      const rows = [["ts","type","count","mode","note"]];
      for(const ev of [...state.events].reverse()){
        rows.push([ev.ts, ev.type, ev.count, ev.mode, ev.note || ""]);
      }
      const csv = rows.map(r=>r.map(v=>`"${String(v).replaceAll('"','""')}"`).join(",")).join("\n");
      const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = `vdc_patas_${(state.sessionName||"sesion").replaceAll(" ","_")}_${Date.now()}.csv`;
      a.click();
      URL.revokeObjectURL(a.href);
      pushEvent("EXPORTAR CSV");
    };

    $("sessionName").oninput = (e)=>{
      state.sessionName = e.target.value || "";
      autosave();
      updateUI();
    };

    $("btnDebug").onclick = ()=>{
      state.debug = !state.debug;
      pushEvent(state.debug ? "DEBUG ON" : "DEBUG OFF");
      autosave();
      updateUI();
    };

    // Cambiar modo: B2 -> B3 -> RF -> B2
    $("btnMode").onclick = ()=>{
      state.mode = (state.mode === "B2") ? "B3" : (state.mode === "B3") ? "RF" : "B2";
      pushEvent("CAMBIO MODO", {note: state.mode});
      autosave();
      updateUI();
    };

    // Calibration (B2)
    $("btnCalib").onclick = ()=>{
      if(state.mode !== "B2"){
        pushEvent("CALIBRAR", {note:"solo B2"});
        return;
      }
      calibrating = true;
      calibStart = performance.now();
      calibSamples = [];
      pushEvent("CALIBRAR", {note:"10s"});
    };

    // sliders
    roi.oninput = ()=>{ state.roiPct = +roi.value; autosave(); updateUI(); };
    lineY.oninput = ()=>{ state.lineYPct = +lineY.value; autosave(); updateUI(); };
    thr.oninput = ()=>{ state.thr = (+thr.value)/100; autosave(); updateUI(); };
    cool.oninput = ()=>{ state.cooldownMs = +cool.value; autosave(); updateUI(); };
    rfConf.oninput = ()=>{ state.rfConf = (+rfConf.value)/100; autosave(); updateUI(); };
    rfFps.oninput = ()=>{ state.rfFps = +rfFps.value; autosave(); updateUI(); };

    // ====== Camera ======
    let stream = null;
    let usingFront = false;

    $("btnFlip").onclick = async ()=>{
      usingFront = !usingFront;
      state.camera.facingMode = usingFront ? "user" : "environment";
      pushEvent("CAMBIO CÁMARA", {note: state.camera.facingMode});
      await stopCamera();
      await startCamera();
    };

    $("btnCamOn").onclick = async ()=>{ await startCamera(); };
    $("btnCamOff").onclick = async ()=>{
      await stopCamera();
      pushEvent("CAMARA_OFF");
    };

    async function startCamera(){
      try{
        if(stream) await stopCamera();
        const constraints = {
          audio:false,
          video:{ facingMode: state.camera.facingMode, width:{ideal:1280}, height:{ideal:720} }
        };
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        await video.play();
        pushEvent("CAMARA_ON");
        autosave();
      }catch(err){
        pushEvent("CAMARA_ERROR", {note: String(err?.message || err)});
        alert("No se pudo activar cámara. Revisa permisos: Safari/Chrome → Cámara → Permitir.");
      }
    }

    async function stopCamera(){
      try{
        if(video.srcObject){ video.pause(); video.srcObject = null; }
        if(stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; }
      }catch(e){}
    }

    // ====== Vision Utils ======
    let lastCountAt = 0;

    function ensureCanvas(){
      const w = video.videoWidth || 1280;
      const h = video.videoHeight || 720;
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
      }
    }

    function getROI(){
      const w = canvas.width, h = canvas.height;
      const pct = state.roiPct/100;
      const rw = Math.floor(w*pct);
      const rh = Math.floor(h*pct);
      const x = Math.floor((w - rw)/2);
      const y = Math.floor((h - rh)/2);
      return {x,y,rw,rh};
    }

    function drawOverlay(metricText=""){
      const {x,y,rw,rh} = getROI();
      const lineYLocal = y + Math.floor(rh*(state.lineYPct/100));

      // ROI box
      ctx.lineWidth = 4;
      ctx.strokeStyle = "rgba(74,163,255,.75)";
      ctx.strokeRect(x,y,rw,rh);

      // line
      ctx.beginPath();
      ctx.moveTo(x, lineYLocal);
      ctx.lineTo(x+rw, lineYLocal);
      ctx.strokeStyle = "rgba(50,208,127,.85)";
      ctx.stroke();

      if(state.debug){
        ctx.fillStyle = "rgba(0,0,0,.55)";
        ctx.fillRect(14, 14, 520, 120);
        ctx.fillStyle = "rgba(255,255,255,.92)";
        ctx.font = "bold 18px ui-sans-serif, system-ui";
        ctx.fillText(`Modo ${state.mode} • ${state.running ? "RUN" : "PAUSE"}`, 24, 42);
        ctx.font = "bold 16px ui-sans-serif, system-ui";
        ctx.fillText(metricText, 24, 70);
        ctx.font = "14px ui-sans-serif, system-ui";
        ctx.fillText(`thr=${state.thr.toFixed(2)} cool=${state.cooldownMs}ms RF conf=${state.rfConf.toFixed(2)} fps=${state.rfFps}`, 24, 96);
      }
    }

    function canCount(){
      const now = performance.now();
      return (now - lastCountAt) > state.cooldownMs;
    }

    function doCount(note="auto"){
      if(!state.running) return;
      if(!canCount()) return;
      state.count += 1;
      lastCountAt = performance.now();
      autosave();
      updateUI();
      countedVisual(note);
    }

    // ====== B2: motion ======
    let lastFrame = null;
    let lastMetric = 0;

    // Calibration
    let calibrating = false;
    let calibStart = 0;
    let calibSamples = [];

    function stepB2(){
      const {x,y,rw,rh} = getROI();
      const frame = ctx.getImageData(x,y,rw,rh);

      if(lastFrame){
        const a = frame.data, b = lastFrame.data;
        let diff = 0;
        for(let i=0; i<a.length; i+=8){
          diff += Math.abs(a[i] - b[i]);
        }
        const norm = diff / ( (a.length/8) * 255 );
        lastMetric = norm;

        if(calibrating){
          calibSamples.push(norm);
          if(performance.now() - calibStart > 10000){
            calibrating = false;
            const base = calibSamples.sort((p,q)=>p-q);
            const p95 = base[Math.floor(base.length*0.95)] || 0.02;
            const newThr = Math.min(0.30, Math.max(0.06, p95*2.4 + 0.02));
            state.thr = +newThr.toFixed(2);
            thr.value = Math.round(state.thr*100);
            pushEvent("CALIBRAR OK", {note:`thr=${state.thr.toFixed(2)}`});
            autosave(); updateUI();
          }
        }

        if(state.running && norm > state.thr){
          doCount(`B2 motion ${norm.toFixed(2)}`);
        }
      }

      lastFrame = frame;
      drawOverlay(`B2 motion=${lastMetric.toFixed(3)}`);
    }

    // ====== B3: OpenCV ======
    let cvReady = false;
    let bgsub = null;
    let kernel = null;
    let lastCross = false;

    function initCVIfNeeded(){
      if(cvReady) return true;
      if(typeof cv === "undefined" || !cv.Mat) return false;
      try{
        bgsub = new cv.BackgroundSubtractorMOG2(300, 16, false);
        kernel = cv.Mat.ones(5,5, cv.CV_8U);
        cvReady = true;
        pushEvent("B3 OpenCV listo");
        autosave();
        return true;
      }catch(e){
        pushEvent("B3 OpenCV error", {note:String(e)});
        return false;
      }
    }

    function stepB3(){
      const ok = initCVIfNeeded();
      const {x,y,rw,rh} = getROI();
      const lineYLocal = y + Math.floor(rh*(state.lineYPct/100));

      let metricText = "B3 cargando OpenCV…";
      if(!ok){ drawOverlay(metricText); return; }

      const img = ctx.getImageData(0,0,canvas.width,canvas.height);
      const src = cv.matFromImageData(img);

      const rect = new cv.Rect(x,y,rw,rh);
      const roiMat = src.roi(rect);

      const fg = new cv.Mat();
      bgsub.apply(roiMat, fg);

      cv.medianBlur(fg, fg, 5);
      cv.threshold(fg, fg, 200, 255, cv.THRESH_BINARY);
      cv.morphologyEx(fg, fg, cv.MORPH_OPEN, kernel);

      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(fg, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      let bestArea = 0, bestRect = null;

      for(let i=0;i<contours.size();i++){
        const c = contours.get(i);
        const area = cv.contourArea(c);
        if(area > bestArea){
          bestArea = area;
          bestRect = cv.boundingRect(c);
        }
      }

      if(bestRect && bestArea >= 1600){
        const gx = x + bestRect.x;
        const gy = y + bestRect.y;
        const gw = bestRect.width;
        const gh = bestRect.height;

        const cx = gx + gw/2;
        const cy = gy + gh/2;

        ctx.lineWidth = 4;
        ctx.strokeStyle = "rgba(202,162,74,.95)";
        ctx.strokeRect(gx,gy,gw,gh);

        ctx.beginPath();
        ctx.arc(cx,cy,8,0,Math.PI*2);
        ctx.fillStyle = "rgba(202,162,74,.95)";
        ctx.fill();

        const nowBelow = (cy >= lineYLocal);
        const crossed = (!lastCross && nowBelow);
        lastCross = nowBelow;

        metricText = `B3 area=${Math.round(bestArea)} cy=${Math.round(cy)} lineY=${lineYLocal}`;
        if(state.running && crossed){
          doCount(`B3 cross area=${Math.round(bestArea)}`);
        }
      }else{
        metricText = `B3 sin objeto (bestArea=${Math.round(bestArea)})`;
        lastCross = false;
      }

      src.delete(); roiMat.delete(); fg.delete(); contours.delete(); hierarchy.delete();
      drawOverlay(metricText);
    }

    // ====== RF (Roboflow) ======
    let rfEngine = null;
    let rfWorkerId = null;
    let rfReady = false;
    let rfLastInferAt = 0;

    // anti-doble conteo por “puntos recientes”
    let recentHits = []; // {x,y,t}
    function pruneHits(){
      const now = performance.now();
      recentHits = recentHits.filter(p => (now - p.t) < 1500);
    }
    function isNearRecent(x,y){
      for(const p of recentHits){
        const dx = x - p.x, dy = y - p.y;
        if((dx*dx + dy*dy) < (70*70)) return true;
      }
      return false;
    }

    async function initRF(){
      if(rfReady) return true;
      if(!window.__RF__) return false;
      try{
        const { InferenceEngine } = window.__RF__;
        rfEngine = new InferenceEngine();
        rfWorkerId = await rfEngine.startWorker(ROBOFLOW_MODEL_ID, ROBOFLOW_PUBLISHABLE_KEY);
        rfReady = true;
        pushEvent("RF Roboflow listo");
        autosave();
        return true;
      }catch(e){
        pushEvent("RF error init", {note:String(e?.message || e)});
        return false;
      }
    }

    function drawRFBoxes(preds, roiInfo){
      const {x,y,rw,rh,lineYLocal} = roiInfo;
      ctx.lineWidth = 4;
      for(const p of preds){
        const conf = p.confidence ?? p.conf ?? 0;
        const cls = p.class ?? p.label ?? "";
        if(cls !== "pata") continue;
        if(conf < state.rfConf) continue;

        // inferencejs suele dar bbox en formato x,y,width,height (centrados o esquina según modelo)
        // En Roboflow JSON de Visualize: x,y = centro. width/height = tamaño.
        const cx = p.x, cy = p.y, w = p.width, h = p.height;

        // convertir a esquina
        const left = (x + (cx - w/2));
        const top  = (y + (cy - h/2));

        ctx.strokeStyle = "rgba(167,139,250,.95)";
        ctx.strokeRect(left, top, w, h);

        // etiqueta
        ctx.fillStyle = "rgba(0,0,0,.55)";
        ctx.fillRect(left, top-24, 150, 22);
        ctx.fillStyle = "rgba(255,255,255,.92)";
        ctx.font = "bold 14px ui-sans-serif, system-ui";
        ctx.fillText(`pata ${(conf*100).toFixed(0)}%`, left+6, top-8);

        // punto centro
        ctx.beginPath();
        ctx.arc(x + cx, y + cy, 7, 0, Math.PI*2);
        ctx.fillStyle = "rgba(167,139,250,.95)";
        ctx.fill();

        // conteo: si centro pasa abajo de línea y no es repetido
        if(state.running && (y+cy) >= lineYLocal){
          pruneHits();
          if(!isNearRecent(x+cx, y+cy) && canCount()){
            recentHits.push({x:x+cx, y:y+cy, t:performance.now()});
            doCount(`RF cross ${(conf*100).toFixed(0)}%`);
          }
        }
      }
    }

    async function stepRF(){
      const ok = await initRF();
      const {x,y,rw,rh} = getROI();
      const lineYLocal = y + Math.floor(rh*(state.lineYPct/100));
      let metricText = "RF cargando…";

      if(!ok){
        drawOverlay(metricText);
        return;
      }

      // throttle infer
      const now = performance.now();
      const interval = 1000 / Math.max(1, state.rfFps);
      if(now - rfLastInferAt < interval){
        drawOverlay("RF esperando (throttle) …");
        return;
      }
      rfLastInferAt = now;

      // recortar ROI a canvas temporal para mandar a Roboflow
      const tmp = document.createElement("canvas");
      tmp.width = rw; tmp.height = rh;
      const tctx = tmp.getContext("2d", { willReadFrequently:true });
      tctx.drawImage(canvas, x, y, rw, rh, 0, 0, rw, rh);

      try{
        const { CVImage } = window.__RF__;
        const img = new CVImage(tmp);
        const preds = await rfEngine.infer(rfWorkerId, img);

        const arr = Array.isArray(preds) ? preds : (preds?.predictions || preds?.preds || []);
        const patas = arr.filter(p => (p.class === "pata") && ((p.confidence ?? 0) >= state.rfConf));

        metricText = `RF preds=${arr.length} patas>=conf=${patas.length} confMin=${state.rfConf.toFixed(2)}`;

        drawRFBoxes(arr, {x,y,rw,rh,lineYLocal});
        drawOverlay(metricText);
      }catch(e){
        metricText = `RF error infer: ${String(e?.message || e)}`;
        pushEvent("RF infer error", {note: metricText});
        drawOverlay(metricText);
      }
    }

    // ====== Main Loop ======
    function loop(){
      requestAnimationFrame(loop);

      if(!video || video.readyState < 2) {
        clockEl.textContent = new Date().toLocaleTimeString();
        return;
      }

      ensureCanvas();

      // draw current video frame
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      if(state.mode === "B2") stepB2();
      else if(state.mode === "B3") stepB3();
      else stepRF();

      clockEl.textContent = new Date().toLocaleTimeString();
    }

    // ====== Boot ======
    load();
    loop();
    setInterval(()=>{ autosave(); }, 15000);
  </script>
</body>
</html>



